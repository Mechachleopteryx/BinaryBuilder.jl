const BUILD_HELP = (
    """
    Usage: build_tarballs.jl [target1,target2,...] [--help]
                             [--verbose] [--debug=mode]
                             [--deploy=repo] [--deploy-bin=repo] [--deploy-jll=repo]
                             [--register] [--meta-json]

    Options:
        targets             By default `build_tarballs.jl` will build a tarball for every
                            target within the `platforms` variable.  To override this,
                            pass in a list of comma-separated target triplets for each
                            target to be built.  Note that this can be used to build for
                            platforms that are not listed in the 'default list' of
                            platforms in the `build_tarballs.jl` script.

        --verbose           This streams compiler and setup code output to `stdout`
                            during the build, which can help track down issues in your
                            build script.

        --debug=<mode>      This causes a failed build to drop into an interactive shell
                            for debugging purposes.  `<mode>` can be one of:
                              - `error` drops you into the interactive shell only when
                                there is an error during the build, this is the default
                                when no mode is specified.
                              - `begin` stops the build at the beginning before any
                                command in the script is run.
                              - `end` stops the build at the end of the build script,
                                useful to inspect a successful build for which the
                                auditor or some other packaging step would fail.

        --deploy=<repo>     Deploy binaries and JLL wrapper code to a github release of
                            an autogenerated repository.  By default, uses the deploy URL
                            `github.com/JuliaBinaryWrappers/<name>_jll.jl` unless
                            `<repo>` is set, in which case it should be set following the
                            template `<owner>/<name>_jll.jl`.  Setting this option is
                            equivalent to setting `--deploy-bin` and `--deploy-jll`.  If
                            `<repo>` is set to "local" then nothing will be uploaded, but
                            JLL packages will still be written out to `~/.julia/dev/`.

        --deploy-bin=<repo> Deploy just the built binaries.

        --deploy-jll=<repo> Deploy just the JLL code wrappers.

        --register=<depot>  Register into the given depot.  If no path is given, defaults
                            to `~/.julia`.  Registration requires deployment of the JLL
                            wrapper code, so so using `--register` without `--deploy` or
                            the more specific `--deploy-jll` is an error.

        --meta-json         Output a JSON representation of the given build instead of
                            actually building.  Note that this can (and often does)
                            output multiple JSON objects for multiple platforms, multi-
                            stage builds, etc...

        --help              Print out this message.

    Examples:
        julia --color=yes build_tarballs.jl --verbose
            This builds all tarballs, with colorized output.

        julia build_tarballs.jl x86_64-linux-gnu,i686-linux-gnu
            This builds two tarballs for the two platforms given, with a
            minimum of output messages.
    """
)

"""
    parse_build_tarballs_args(ARGS::Vector{String})

Parse the arguments passed in to a `build_tarballs.jl` into a dictionary that can be
splatted into `BuildMeta()`.
"""
function parse_build_tarballs_args(ARGS::Vector{String})
    parsed_kwargs = Dict{Symbol,Any}()

    if check_flag(ARGS, "--help")
        println(BUILD_HELP)
        exit(0)
    end

    # --verbose; simple boolean
    parsed_kwargs[:verbose] = check_flag!(ARGS, "--verbose")

    # This sets whether we drop into a debug shell on failure or not
    debug, debug_mode = extract_flag!(ARGS, "--debug", "error")
    if debug
        parsed_kwargs[:debug] = debug_mode
    end

    # Are we skipping building and just outputting JSON?
    meta_json, meta_json_file = extract_flag!(ARGS, "--meta-json")
    if meta_json
        if meta_json_file === nothing
            parsed_kwargs[:json_output] = stdout
        else
            parsed_kwargs[:json_output] = meta_json_file
        end
    end

    deploy, deploy_repo = extract_flag!(ARGS, "--deploy", "JuliaBinaryWrappers/$(src_name)_jll.jl")
    deploy_bin, deploy_bin_repo = extract_flag!(ARGS, "--deploy-bin", "JuliaBinaryWrappers/$(src_name)_jll.jl")
    deploy_jll, deploy_jll_repo = extract_flag!(ARGS, "--deploy-jll", "JuliaBinaryWrappers/$(src_name)_jll.jl")

    if deploy
        parsed_kwargs[:deploy_bin_repo] = deploy_repo
        parsed_kwargs[:deploy_jll_repo] = deploy_repo
    end
    if deploy_bin
        parsed_kwargs[:deploy_bin_repo] = deploy_bin_repo
    end
    if deploy_jll
        parsed_kwargs[:deploy_jll_repo] = deploy_jll_repo
    end

    register, register_path = extract_flag!(ARGS, "--register", Pkg.depots1())
    if register
        parsed_kwargs[:register] = register_path
    end

    # Slurp up the last argument as platforms
    if length(ARGS) > 0
        parse_platform(p::AbstractString) = p == "any" ? AnyPlatform() : parse(Platform, p; validate_strict=true)
        parsed_kwargs[:target_list] = parse_platform.(split(ARGS[1], ","))
    end

    return parsed_kwargs
end



"""
    BuildConfig

This structure holds all of the inputs that are needed to generate a build of a software
project in the build environment.  Things such as the project name, the list of sources,
the build script, the dependencies, etc... are all listed within this structure.  Once
the users calls `build!()`, each `BuildConfig` will get a `BuildResult` packed into the
overall `BuildMeta` object.
"""
struct BuildConfig
    # The name of the package being built.  This is exported as an environment variable during build
    # so that internal tooling such as "install_license" can install into intelligent paths.
    src_name::String

    # The source version; this may not be what the resultant JLL gets published under, but it will
    # be recorded as metadata in the JLL itself.
    src_version::VersionNumber

    # Sources that we will build from (Git repositories, tarballs, directories on-disk, etc...)
    sources::Vector{<:AbstractSource}

    # Dependencies that must be installed in the build environment.
    # Contains host and target dependencies.
    dependencies::Vector{<:AbstractDependency}

    # The compiler packages to mount within the rootfs.  In a future update, this will be
    # merged into `dependencies`, once we are properly constructing our build environment
    # through things like `GCC_jll` and `Clang_jll`, instead of special compiler shards.
    compilers::Vector{Symbol}

    # Bash script that will perform the actual build itself
    script::AbstractString

    # The platform this build will target; fully-specified.
    target::AbstractPlatform
end

"""
    BuildResult

A `BuildResult` represents a constructed build prefix; it contains the paths to the
binaries (typically within an artifact directory) as well as some metadata about the
audit passes and whatnot that ran upon the files.
"""
struct BuildResult
    # The config that this result was built from
    config::BuildConfig

    # The overall status of the build; e.g. `:complete`.
    status::Symbol

    # The location of the build prefix on-disk (typically an artifact directory)
    prefix::String

    # Logs that are generated from build invocations and audit passes.
    # Key name is an identifier for the operation, value is the log content.
    # Example: ("audit-libfoo-relink_to_rpath").  When this `BuildResult` is packaged,
    # the logs will be written to `$(prefix)/logs/$(src_name)-$(log_name).log`
    logs::Dict{String,String}

    # These are `@info`/`@warn`/`@error` messages that get emitted during the build/audit
    # we may eventually want to make this more structured, e.g. organize them by audit
    # pass and whatnot.  These messages are not written out to disk during packaging.
    msgs::Vector{LogRecord}
end

"""
    PackageConfig

This structure holds all the inputs needed to package a new JLL release.  It requires a
set of `BuildResult`s that it will then package up into a new JLL, optionally deploying
the build results onto GitHub releases, etc...
"""
struct PackageConfig
    # The build results we're packaging up
    builds::Vector{BuildResult}

    # The name of the JLL we're going to package into.  E.g. "Zlib"
    name::String

    # The extraction script that we're using to copy build results out into our artifacts
    script::String

    # The products that this package will ensure are available
    products::Vector{<:Product}
end

struct PackageResult
    # Link back to the originating Package Config
    config::PackageConfig

    # The version number this package result is getting published under (may disagree with `src_version`)
    published_version::VersionNumber

    # Treehashes that represent the packaged outputs for this JLL release
    artifacts::Vector{Base.SHA1}

    # The location the code was all written out to (or nothing, if no JLL code was generated)
    code_dir::Union{String,Nothing}

    # The location the code/binaries were deployed to (or `nothing`, if it was not deployed)
    deploy_target::Union{String,Nothing}
end

"""
    BuildMeta

This structure holds the metadata of a BinaryBuilder session including all build inputs,
all artifacts generated, the JLL packages uploaded, etc...

When constructed, global options (most commonly passed in on the command line through
`ARGS`) can be passed to the `BuildMeta` through a `BuildMeta(ARGS::Vector{String})`
parsing method, or directly through keyword arguments in the constructor.
"""
struct BuildMeta
    # Contains a list of builds; when you run build!() with arguments, it records
    # what the metadata for that build was in here.
    builds::Dict{BuildConfig,Union{Nothing,BuildResult}}

    # Contains a list of JLL packages; when you run `package!()` with arguments, it
    # records the pieces that were generated here.
    packages::Dict{PackageConfig,Union{Nothing,PackageResult}}

    # Options that get toggled by the user through `ARGS`; see `BUILD_HELP` below
    # for more detail.
    target_list::Union{Nothing,Vector{Platform}}
    verbose::Bool
    debug::Union{Nothing,String}
    json_output::Union{Nothing,String,IO}
    deploy_bin_repo::Union{Nothing,String}
    deploy_jll_repo::Union{Nothing,String}
    register::Union{Nothing,String}

    function BuildMeta(target_list::Union{Nothing,Vector{Platform}} = nothing,
                       verbose::Bool = false,
                       debug::Union{Nothing,String} = nothing,
                       json_output::Union{Nothing,String,IO} = nothing,
                       deploy_bin_repo::Union{Nothing,String} = nothing,
                       deploy_jll_repo::Union{Nothing,String} = nothing,
                       register::Union{Nothing,String} = nothing,
                       )
        if target_list !== nothing
            if isempty(target_list)
                throw(ArgumentError("If `target_list` is specified, it must contain a non-zero number of platforms to build for!"))
            end
        end

        if debug !== nothing
            if debug ∉ ("begin", "end", "error")
                throw(ArgumentError("If `debug` is specified, it must be one of \"begin\", \"end\" or \"error\""))
            end
        end

        if deploy_bin_repo !== nothing && deploy_jll_repo !== nothing && deploy_bin_repo != deploy_jll_repo
            throw(ArgumentError("If `deploy_bin_repo` and `deploy_jll_repo` are both specified, they must match!"))
        end

        if register !== nothing
            if deploy_jll_repo === nothing
                throw(ArgumentError("Cannot register without deploying the JLL somewhere!"))
            else
                if deploy_jll_repo == "local"
                    throw(ArgumentError("Cannot register while deploying locally!"))
                end
            end
        end

        return new(
            Dict{BuildConfig,BuildResult}(),
            Dict{BuildResult,PackageResult}(),
            target_list,
            verbose,
            debug,
            json_output,
            deploy_bin_repo,
            deploy_jll_repo,
            register,
        )
    end
end

"""
    BuildMeta(ARGS::Vector{String})

Convenience constructor that calls `parse_build_tarballs_args()` on `ARGS`.
"""
BuildMeta(ARGS::Vector{String}) = BuildMeta(;parse_build_tarballs_args(ARGS)...)

# TODO: Add serialization tools for all of these structures